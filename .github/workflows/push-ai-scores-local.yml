name: Push AI Scores (local joblib)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 9-20 * * 1-5"  # every 5m during premarket+RTH (UTC)

jobs:
  push:
    runs-on: ubuntu-latest
    env:
      APP_URL: ${{ vars.APP_URL }}              # e.g. https://your-app.vercel.app
      SCORES_API_KEY: ${{ secrets.SCORES_API_KEY }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install numpy pandas joblib scikit-learn requests

      - name: Fetch /api/stocks
        run: |
          curl -fsS "${APP_URL}/api/stocks" -H "accept: application/json" -o stocks.json
          head -c 400 stocks.json || true
          echo

      - name: Build scores with local model & POST
        run: |
          python - <<'PY'
          import os, json, math, time
          import numpy as np, pandas as pd, joblib, requests

          APP_URL = os.environ["APP_URL"].rstrip("/")
          KEY = os.environ.get("SCORES_API_KEY","")

          # Load model
          MODEL_CANDIDATES = ["printedai_score.joblib","ai_score.joblib","model.joblib"]
          model_path = next((p for p in MODEL_CANDIDATES if os.path.exists(p)), None)
          if not model_path:
            raise FileNotFoundError(f"No joblib model found; tried {MODEL_CANDIDATES}")
          print("Model:", model_path)
          model = joblib.load(model_path)

          # Load stocks
          rows = json.load(open("stocks.json")).get("data", [])
          def fnum(x):
            try:
              s = str(x).strip()
              if s.endswith("%"): s = s[:-1]
              return float(s)
            except: return None

          recs = []
          for r in rows:
            t = str(r.get("symbol") or r.get("ticker") or "").upper()
            if not t: continue
            gap = fnum(r.get("gap") or r.get("gap_pct") or r.get("gapPct") or r.get("change") or r.get("change_pct"))
            chg = fnum(r.get("change") or r.get("change_pct"))
            rvol = fnum(r.get("relativeVolume") or r.get("relVolume") or r.get("rvol"))
            # rVol fallback for big gaps
            if (rvol is None) or (rvol is not None and rvol <= 0):
              if gap is not None and gap >= 40: rvol = 4.5
              elif gap is not None and gap >= 20: rvol = 3.0
            float_m = fnum(r.get("floatM") or r.get("float_m")) \
                      or ((fnum(r.get("float_shares")) or 0)/1e6 if r.get("float_shares") is not None else None)
            recs.append({
              "ticker": t,
              "gap_pct": gap,
              "rvol": rvol,
              "float_m": float_m,
              "price": fnum(r.get("price")),
              "rsi14m": fnum(r.get("rsi14m") or r.get("rsi")),
              "volume": fnum(r.get("volume")),
              "change_pct": chg,
            })

          df = pd.DataFrame.from_records(recs)
          if df.empty:
            print("No rows from /api/stocks")
            raise SystemExit(0)

          FEATURE_COLS = ["gap_pct","rvol","float_m","price","rsi14m"]
          for c in FEATURE_COLS:
            if c not in df.columns: df[c] = np.nan
          X = df[FEATURE_COLS].astype(float).fillna(0.0)

          # Heuristic score to blend when model is degenerate
          def clamp(v, lo=0.0, hi=1.0): return max(lo, min(hi, float(v)))
          h_rv = clamp(((df["rvol"].fillna(1.0) - 1.0)/4.0))
          h_gap = clamp((df["gap_pct"].abs().fillna(0.0)/20.0))
          h_chg = clamp((df["change_pct"].fillna(0.0).clip(lower=0)/10.0))
          h_float = np.where((df["float_m"].fillna(999) <= 20), 0.05, 0.0)  # small float bonus
          heuristic = clamp(0.55*h_rv + 0.30*h_gap + 0.15*h_chg + h_float)

          # Model inference
          def to01(arr):
            arr = np.asarray(arr, dtype=float).ravel()
            mn, mx = float(np.min(arr)), float(np.max(arr))
            if not np.isfinite(mn) or not np.isfinite(mx): return np.zeros_like(arr)
            if math.isclose(mx, mn): return np.full_like(arr, 0.5)  # neutral if constant
            return (arr - mn) / (mx - mn)

          if hasattr(model, "predict_proba"):
            proba = model.predict_proba(X)
            if proba.ndim == 2 and proba.shape[1] >= 2:
              model_score = proba[:,1]
            else:
              model_score = proba.ravel()
            model_score = np.clip(model_score, 0, 1)
          else:
            pred = model.predict(X)
            model_score = to01(pred)  # avoid all-zeros if constant

          # Blend: if model looks degenerate (low variance or 1 row), lean on heuristic
          if len(model_score) < 5 or np.std(model_score) < 1e-6:
            final = heuristic
          else:
            final = 0.7*model_score + 0.3*heuristic
          final = np.clip(final, 0, 1)

          payload = {
            "generatedAt": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            "scores": [
              {
                "ticker": df.at[i,"ticker"],
                "score": float(final[i]),
                "gap_pct": float(df.at[i,"gap_pct"]) if pd.notnull(df.at[i,"gap_pct"]) else None,
                "rvol": float(df.at[i,"rvol"]) if pd.notnull(df.at[i,"rvol"]) else None,
                "rsi14m": float(df.at[i,"rsi14m"]) if pd.notnull(df.at[i,"rsi14m"]) else None,
                "price": float(df.at[i,"price"]) if pd.notnull(df.at[i,"price"]) else None,
                "volume": float(df.at[i,"volume"]) if pd.notnull(df.at[i,"volume"]) else None,
              }
              for i in range(len(df))
            ],
          }

          print("Posting", len(payload["scores"]), "scores")
          r = requests.post(
            f"{APP_URL}/api/scores",
            headers={"content-type": "application/json", "x-api-key": KEY},
            data=json.dumps(payload),
            timeout=45
          )
          r.raise_for_status()
          print("OK:", r.status_code)
          PY
